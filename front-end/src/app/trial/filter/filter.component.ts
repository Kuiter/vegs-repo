import { Component, OnInit, Output, EventEmitter, ElementRef, ViewChild, AfterViewInit, HostListener } from '@angular/core';
import { FilterService } from '../trial-services/filter.service';
import { NestedTreeControl } from '@angular/cdk/tree';
import { MatTreeNestedDataSource } from '@angular/material/tree';
import { ProductService } from '../trial-services/product.service';

/** Flat node with expandable and level information */
interface ExampleFlatNode {
  expandable: boolean;
  name: string;
  level: number;
}

/**
 * Filter Comopnent contains all elements for filtering the items diplayed in item grid.
 */
@Component({
  selector: 'app-filter',
  templateUrl: './filter.component.html',
  styleUrls: ['./filter.component.scss']
})
export class FilterComponent implements OnInit {
  /**Stores all custom filter trees created for the treatment. Used for ngFor in template. */
  Trees: any[] = [];
  /**Only true if any custom filters are present. Switch for diplaying custom filters in template. */
  showArray = false;
  /**Stores the base category filter tree automatically generated by the product.service at the start of the treatment. */
  sortByTagsTree: any;
  /**Tree control for mat-tree for category filter. */
  tagTreeControl = new NestedTreeControl<any>(node => node.children);
  /**Switch for displaying the category filter. */
  showTagFilter = false;
  /**Stores reference to currently selected node. Used to highlight the tree node. */
  selectedNode: any;

  // baseAttribute Filter
  /**Stores all selected baseAttributs included in limit selection filter. */
  baseAttributes = [];

  /**
   * Injecting services to be used in component.
   * @param filterService 
   * @param productService 
   */
  constructor(private filterService: FilterService, private productService: ProductService) { }
  /**
   * OnInit Funtion collects all necessary data form the services and decides the display options for the filters present.
   * Initiates listener to react to resetFilter event.
   */
  ngOnInit() {
    this.filterService.getFilterTrees().subscribe((val: any[]) => {
      // val = val.concat([{name: 'Sort by Tags',tree: this.productService.getTreeOfTagsOfAllProducts()}]);
      val.forEach((element, i) => {
        this.pushNodes(element);
        if (i == val.length - 1) {
          this.showArray = true;
        }
      });
    });
    // sort by tags
    this.sortByTagsTree = this.productService.getTreeOfTagsOfAllProducts();
    if (this.sortByTagsTree.length > 0) {
      this.showTagFilter = true
    }
    this.productService.getBaseAttributes().forEach(val => this.baseAttributes.push({ name: val, selected: false }))
    if (!!this.filterService.selectedFilter && this.filterService.selectedFilter.type == 'limitSelection') {
      for (let l of this.filterService.selectedFilter.filter) {
        const ind = this.baseAttributes.findIndex(x => x.name == l);
        if (ind >= 0) {
          this.baseAttributes[ind].selected = true;
        }
      }
    }
    this.filterService.resetFilter.subscribe(() => {
      if (this.selectedNode) {
        this.selectedNode.selected = false;
        this.selectedNode = null;
      }
      if (this.baseAttributes.some(o => o.selected == true)) {
        this.baseAttributes.forEach(element => { element.selected = false });
        this.limitSelection('');
      }
    })
  }
  /**
   * https://material.angular.io/components/tree/overview
   * @param el 
   */
  pushNodes(el) {
    let treeControl = new NestedTreeControl<any>(node => node.children);
    let dataSource = new MatTreeNestedDataSource<any>();
    let obj = {
      treeControl: treeControl,
      dataSource: dataSource,
      data: el
    }
    obj.dataSource.data = el.tree;
    obj.treeControl.dataNodes = el.tree;
    obj.treeControl.expandAll();
    this.Trees.push(obj)
  }
  /**
   * https://material.angular.io/components/tree/overview
   */
  hasChild = (_: number, node: any) => !!node.children && node.children.length > 0;
  /**
   * OnClick listener at tree node level for parent category level (not implemented). 
   * @param node 
   */
  filter(node) {
    this.deselectPreviousNode()
    node.selected = true;
    this.selectedNode = node;
    this.filterService.categoryFilter(node.name);
  }
  /**
   * OnClick listener on leaf level of mat-tree. Here a filter action / event is started
   * @param node 
   */
  baseItemFilter(node) {
    this.deselectPreviousNode();
    node.selected = true;
    this.selectedNode = node;
    if (!node.items) {
      return this.filterService.filterItems(node.name, 'tagFilter');
    }
    return this.filterService.filterItems(node.items, 'filterTree');
  }
  /**
   * Helper funktion to be called to deselct previously selected tree node from filter tree.
   */
  deselectPreviousNode(): void {
    if (!this.selectedNode) { return }
    this.selectedNode.selected = false;
  }

  /**
   * Used to limit the selection of current items displayed based on their base Attributes.
   * Operated by change listener on mat-checkbox.
   * @param {String} base 
   */
  limitSelection(base): void {
    let limit = [];
    this.baseAttributes.forEach(element => {
      if (element.selected) {
        limit.push(element.name);
      }
    })
    if (limit.length == 0) {
      if (this.selectedNode != null) {
        this.filterService.filterItems(this.selectedNode.name, 'tagFilter');
        return;
      }
      this.filterService.resetFilterEmit();
      return;
    }
    this.filterService.filterItems(limit, 'limitSelection');
  }

  /**
   * @ignore
   */
  resetFilter() {
    const filter = { filter: 'reset', type: 'general' }
    // this.eventsService.recordSorting(filter);
    this.productService.filteredItems = undefined;
    this.filterService.resetFilterEmit();
  }
}
